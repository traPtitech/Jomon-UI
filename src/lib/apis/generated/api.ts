/* tslint:disable */
/* eslint-disable */
/**
 * Jomon API
 * JomonのAPIです。
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


// @ts-ignore error happens by importsNotUsedAsValues
import { Configuration } from './configuration';
// @ts-ignore error happens by importsNotUsedAsValues
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'status': ApplicationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'content': string;
    /**
     * 
     * @type {Array<ApplicationTargetDetail>}
     * @memberof Application
     */
    'targets': Array<ApplicationTargetDetail>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Application
     */
    'tags': Array<Tag>;
    /**
     * 
     * @type {Partition}
     * @memberof Application
     */
    'partition': Partition;
}

export const ApplicationStatusEnum = {
    Submitted: 'submitted',
    ChangeRequested: 'change_requested',
    Approved: 'approved',
    PaymentFinished: 'payment_finished',
    Rejected: 'rejected'
} as const;

export type ApplicationStatusEnum = typeof ApplicationStatusEnum[keyof typeof ApplicationStatusEnum];

/**
 * 
 * @export
 * @interface ApplicationDetail
 */
export interface ApplicationDetail {
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'id': string;
    /**
     * 
     * @type {StatusEnum}
     * @memberof ApplicationDetail
     */
    'status': StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'created_by': string;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof ApplicationDetail
     */
    'comments': Array<Comment>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationDetail
     */
    'files': Array<string>;
    /**
     * 
     * @type {Array<Status>}
     * @memberof ApplicationDetail
     */
    'statuses': Array<Status>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ApplicationDetail
     */
    'tags': Array<Tag>;
    /**
     * 
     * @type {Partition}
     * @memberof ApplicationDetail
     */
    'partition': Partition;
    /**
     * 
     * @type {Array<ApplicationTargetDetail>}
     * @memberof ApplicationDetail
     */
    'targets': Array<ApplicationTargetDetail>;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationDetail
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ApplicationFile
 */
export interface ApplicationFile {
    /**
     * 
     * @type {any}
     * @memberof ApplicationFile
     */
    'file': any;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFile
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApplicationTarget
 */
export interface ApplicationTarget {
    /**
     * 
     * @type {number}
     * @memberof ApplicationTarget
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationTarget
     */
    'target': string;
}
/**
 * 
 * @export
 * @interface ApplicationTargetDetail
 */
export interface ApplicationTargetDetail {
    /**
     * 
     * @type {string}
     * @memberof ApplicationTargetDetail
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationTargetDetail
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationTargetDetail
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationTargetDetail
     */
    'paid_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationTargetDetail
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface AuthInfo
 */
export interface AuthInfo {
    /**
     * 
     * @type {string}
     * @memberof AuthInfo
     */
    'code_challenge'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthInfo
     */
    'code_challenge_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthInfo
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthInfo
     */
    'response_type'?: string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface FileMeta
 */
export interface FileMeta {
    /**
     * 
     * @type {string}
     * @memberof FileMeta
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FileMeta
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FileMeta
     */
    'mime_type': string;
    /**
     * 
     * @type {string}
     * @memberof FileMeta
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface Partition
 */
export interface Partition {
    /**
     * 
     * @type {string}
     * @memberof Partition
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Partition
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Partition
     */
    'budget': number | null;
    /**
     * 
     * @type {PartitionManagement}
     * @memberof Partition
     */
    'management': PartitionManagement;
    /**
     * 
     * @type {string}
     * @memberof Partition
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Partition
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface PartitionManagement
 */
export interface PartitionManagement {
    /**
     * 管理カテゴリ
     * @type {string}
     * @memberof PartitionManagement
     */
    'category': PartitionManagementCategoryEnum;
    /**
     * パーティションの利用可能状態
     * @type {string}
     * @memberof PartitionManagement
     */
    'state': PartitionManagementStateEnum;
}

export const PartitionManagementCategoryEnum = {
    Manual: 'manual'
} as const;

export type PartitionManagementCategoryEnum = typeof PartitionManagementCategoryEnum[keyof typeof PartitionManagementCategoryEnum];
export const PartitionManagementStateEnum = {
    Available: 'available',
    Unavailable: 'unavailable'
} as const;

export type PartitionManagementStateEnum = typeof PartitionManagementStateEnum[keyof typeof PartitionManagementStateEnum];

/**
 * 
 * @export
 * @interface PostApplication
 */
export interface PostApplication {
    /**
     * 
     * @type {string}
     * @memberof PostApplication
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof PostApplication
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PostApplication
     */
    'content': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostApplication
     */
    'tags': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostApplication
     */
    'partition': string;
    /**
     * 
     * @type {Array<ApplicationTarget>}
     * @memberof PostApplication
     */
    'targets': Array<ApplicationTarget>;
}
/**
 * 
 * @export
 * @interface PostComment
 */
export interface PostComment {
    /**
     * 
     * @type {string}
     * @memberof PostComment
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface PostPartition
 */
export interface PostPartition {
    /**
     * 
     * @type {string}
     * @memberof PostPartition
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PostPartition
     */
    'budget': number | null;
    /**
     * 
     * @type {PartitionManagement}
     * @memberof PostPartition
     */
    'management': PartitionManagement;
}
/**
 * 
 * @export
 * @interface PostTag
 */
export interface PostTag {
    /**
     * 
     * @type {string}
     * @memberof PostTag
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PutStatus
 */
export interface PutStatus {
    /**
     * 
     * @type {StatusEnum}
     * @memberof PutStatus
     */
    'status': StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PutStatus
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface PutUser
 */
export interface PutUser {
    /**
     * 
     * @type {string}
     * @memberof PutUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PutUser
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof PutUser
     */
    'account_manager': boolean;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'created_by': string;
    /**
     * 
     * @type {StatusEnum}
     * @memberof Status
     */
    'status': StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface StatusDetail
 */
export interface StatusDetail {
    /**
     * 
     * @type {string}
     * @memberof StatusDetail
     */
    'created_by': string;
    /**
     * 
     * @type {StatusEnum}
     * @memberof StatusDetail
     */
    'status': StatusEnum;
    /**
     * 
     * @type {Comment}
     * @memberof StatusDetail
     */
    'comment'?: Comment;
    /**
     * 
     * @type {string}
     * @memberof StatusDetail
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StatusEnum = {
    Submitted: 'submitted',
    ChangeRequested: 'change_requested',
    Approved: 'approved',
    PaymentFinished: 'payment_finished',
    Rejected: 'rejected'
} as const;

export type StatusEnum = typeof StatusEnum[keyof typeof StatusEnum];


/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'display_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'account_manager': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'deleted_at': string | null;
}

/**
 * AccountManagersApi - axios parameter creator
 * @export
 */
export const AccountManagersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * accountManagerユーザーを削除する。accountManager権限が必要。
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountManagers: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteAccountManagers', 'requestBody', requestBody)
            const localVarPath = `/account-managers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * accountManagerユーザーの一覧を返す。accountManager権限が必要。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountManagers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account-managers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * accountManagerユーザーを追加する。accountManager権限が必要。
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountManagers: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('postAccountManagers', 'requestBody', requestBody)
            const localVarPath = `/account-managers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountManagersApi - functional programming interface
 * @export
 */
export const AccountManagersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountManagersApiAxiosParamCreator(configuration)
    return {
        /**
         * accountManagerユーザーを削除する。accountManager権限が必要。
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountManagers(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountManagers(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * accountManagerユーザーの一覧を返す。accountManager権限が必要。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountManagers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountManagers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * accountManagerユーザーを追加する。accountManager権限が必要。
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAccountManagers(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAccountManagers(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountManagersApi - factory interface
 * @export
 */
export const AccountManagersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountManagersApiFp(configuration)
    return {
        /**
         * accountManagerユーザーを削除する。accountManager権限が必要。
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountManagers(requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccountManagers(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * accountManagerユーザーの一覧を返す。accountManager権限が必要。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountManagers(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getAccountManagers(options).then((request) => request(axios, basePath));
        },
        /**
         * accountManagerユーザーを追加する。accountManager権限が必要。
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountManagers(requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.postAccountManagers(requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountManagersApi - object-oriented interface
 * @export
 * @class AccountManagersApi
 * @extends {BaseAPI}
 */
export class AccountManagersApi extends BaseAPI {
    /**
     * accountManagerユーザーを削除する。accountManager権限が必要。
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountManagersApi
     */
    public deleteAccountManagers(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return AccountManagersApiFp(this.configuration).deleteAccountManagers(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * accountManagerユーザーの一覧を返す。accountManager権限が必要。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountManagersApi
     */
    public getAccountManagers(options?: AxiosRequestConfig) {
        return AccountManagersApiFp(this.configuration).getAccountManagers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * accountManagerユーザーを追加する。accountManager権限が必要。
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountManagersApi
     */
    public postAccountManagers(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return AccountManagersApiFp(this.configuration).postAccountManagers(requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定した申請の詳細を取得する。
         * @param {string} applicationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDetail: async (applicationID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationID' is not null or undefined
            assertParamExists('getApplicationDetail', 'applicationID', applicationID)
            const localVarPath = `/applications/{applicationID}`
                .replace(`{${"applicationID"}}`, encodeURIComponent(String(applicationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 申請一覧を取得する。
         * @param {string} [sort] 並び順 (作成日時が新しい \&quot;created_at\&quot;, 作成日時が古い \&quot;-created_at\&quot;, タイトルの昇順 \&quot;title\&quot;, タイトルの降順 \&quot;-title\&quot;)
         * @param {StatusEnum} [status] 現在の状態
         * @param {string} [target] 誰との取引か
         * @param {string} [since] いつからの依頼か
         * @param {string} [until] いつまでの依頼か
         * @param {number} [limit] 取得する最大個数
         * @param {number} [offset] スキップする個数
         * @param {string} [tag] タグ(複数の場合カンマ区切り)
         * @param {string} [partition] パーティション
         * @param {string} [createdBy] 作成者
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplications: async (sort?: string, status?: StatusEnum, target?: string, since?: string, until?: string, limit?: number, offset?: number, tag?: string, partition?: string, createdBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString().substr(0,10) :
                    since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = (until as any instanceof Date) ?
                    (until as any).toISOString().substr(0,10) :
                    until;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 申請を新規作成する。
         * @param {PostApplication} postApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplication: async (postApplication: PostApplication, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postApplication' is not null or undefined
            assertParamExists('postApplication', 'postApplication', postApplication)
            const localVarPath = `/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postApplication, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定した申請にコメントを新規作成する。
         * @param {string} applicationID 
         * @param {PostComment} postComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment: async (applicationID: string, postComment: PostComment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationID' is not null or undefined
            assertParamExists('postComment', 'applicationID', applicationID)
            // verify required parameter 'postComment' is not null or undefined
            assertParamExists('postComment', 'postComment', postComment)
            const localVarPath = `/applications/{applicationID}/comments`
                .replace(`{${"applicationID"}}`, encodeURIComponent(String(applicationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定した申請を修正する。作成者権限が必要。
         * @param {string} applicationID 
         * @param {PostApplication} postApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApplicationDetail: async (applicationID: string, postApplication: PostApplication, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationID' is not null or undefined
            assertParamExists('putApplicationDetail', 'applicationID', applicationID)
            // verify required parameter 'postApplication' is not null or undefined
            assertParamExists('putApplicationDetail', 'postApplication', postApplication)
            const localVarPath = `/applications/{applicationID}`
                .replace(`{${"applicationID"}}`, encodeURIComponent(String(applicationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postApplication, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定した申請のstatusを変更のみ(新規はpost /applications)する。commentは常に必須(ないときは空文字列)。statusの行き来の定義は作成者は「change_requestedからsubmitted」をでき、accountManagerは「submittedからrejected」「submittedからchange_requested」「change_requestedからsubmitted」「submittedからapproved」「approvedからsubmitted（ただしすでに支払われている人がいた場合、この操作は不可)」の操作のみ可。ただし、「approvedからfully_repaid」の操作はここでは行えない。accountManager権限または作成者権限が必要。
         * @param {string} applicationID 
         * @param {PutStatus} putStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putStatus: async (applicationID: string, putStatus: PutStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationID' is not null or undefined
            assertParamExists('putStatus', 'applicationID', applicationID)
            // verify required parameter 'putStatus' is not null or undefined
            assertParamExists('putStatus', 'putStatus', putStatus)
            const localVarPath = `/applications/{applicationID}/status`
                .replace(`{${"applicationID"}}`, encodeURIComponent(String(applicationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定した申請の詳細を取得する。
         * @param {string} applicationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationDetail(applicationID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationDetail(applicationID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 申請一覧を取得する。
         * @param {string} [sort] 並び順 (作成日時が新しい \&quot;created_at\&quot;, 作成日時が古い \&quot;-created_at\&quot;, タイトルの昇順 \&quot;title\&quot;, タイトルの降順 \&quot;-title\&quot;)
         * @param {StatusEnum} [status] 現在の状態
         * @param {string} [target] 誰との取引か
         * @param {string} [since] いつからの依頼か
         * @param {string} [until] いつまでの依頼か
         * @param {number} [limit] 取得する最大個数
         * @param {number} [offset] スキップする個数
         * @param {string} [tag] タグ(複数の場合カンマ区切り)
         * @param {string} [partition] パーティション
         * @param {string} [createdBy] 作成者
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplications(sort?: string, status?: StatusEnum, target?: string, since?: string, until?: string, limit?: number, offset?: number, tag?: string, partition?: string, createdBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Application>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplications(sort, status, target, since, until, limit, offset, tag, partition, createdBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 申請を新規作成する。
         * @param {PostApplication} postApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApplication(postApplication: PostApplication, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApplication(postApplication, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定した申請にコメントを新規作成する。
         * @param {string} applicationID 
         * @param {PostComment} postComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postComment(applicationID: string, postComment: PostComment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postComment(applicationID, postComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定した申請を修正する。作成者権限が必要。
         * @param {string} applicationID 
         * @param {PostApplication} postApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putApplicationDetail(applicationID: string, postApplication: PostApplication, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putApplicationDetail(applicationID, postApplication, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定した申請のstatusを変更のみ(新規はpost /applications)する。commentは常に必須(ないときは空文字列)。statusの行き来の定義は作成者は「change_requestedからsubmitted」をでき、accountManagerは「submittedからrejected」「submittedからchange_requested」「change_requestedからsubmitted」「submittedからapproved」「approvedからsubmitted（ただしすでに支払われている人がいた場合、この操作は不可)」の操作のみ可。ただし、「approvedからfully_repaid」の操作はここでは行えない。accountManager権限または作成者権限が必要。
         * @param {string} applicationID 
         * @param {PutStatus} putStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putStatus(applicationID: string, putStatus: PutStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putStatus(applicationID, putStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * 指定した申請の詳細を取得する。
         * @param {string} applicationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationDetail(applicationID: string, options?: any): AxiosPromise<ApplicationDetail> {
            return localVarFp.getApplicationDetail(applicationID, options).then((request) => request(axios, basePath));
        },
        /**
         * 申請一覧を取得する。
         * @param {string} [sort] 並び順 (作成日時が新しい \&quot;created_at\&quot;, 作成日時が古い \&quot;-created_at\&quot;, タイトルの昇順 \&quot;title\&quot;, タイトルの降順 \&quot;-title\&quot;)
         * @param {StatusEnum} [status] 現在の状態
         * @param {string} [target] 誰との取引か
         * @param {string} [since] いつからの依頼か
         * @param {string} [until] いつまでの依頼か
         * @param {number} [limit] 取得する最大個数
         * @param {number} [offset] スキップする個数
         * @param {string} [tag] タグ(複数の場合カンマ区切り)
         * @param {string} [partition] パーティション
         * @param {string} [createdBy] 作成者
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplications(sort?: string, status?: StatusEnum, target?: string, since?: string, until?: string, limit?: number, offset?: number, tag?: string, partition?: string, createdBy?: string, options?: any): AxiosPromise<Array<Application>> {
            return localVarFp.getApplications(sort, status, target, since, until, limit, offset, tag, partition, createdBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 申請を新規作成する。
         * @param {PostApplication} postApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplication(postApplication: PostApplication, options?: any): AxiosPromise<ApplicationDetail> {
            return localVarFp.postApplication(postApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定した申請にコメントを新規作成する。
         * @param {string} applicationID 
         * @param {PostComment} postComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment(applicationID: string, postComment: PostComment, options?: any): AxiosPromise<Comment> {
            return localVarFp.postComment(applicationID, postComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定した申請を修正する。作成者権限が必要。
         * @param {string} applicationID 
         * @param {PostApplication} postApplication 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putApplicationDetail(applicationID: string, postApplication: PostApplication, options?: any): AxiosPromise<ApplicationDetail> {
            return localVarFp.putApplicationDetail(applicationID, postApplication, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定した申請のstatusを変更のみ(新規はpost /applications)する。commentは常に必須(ないときは空文字列)。statusの行き来の定義は作成者は「change_requestedからsubmitted」をでき、accountManagerは「submittedからrejected」「submittedからchange_requested」「change_requestedからsubmitted」「submittedからapproved」「approvedからsubmitted（ただしすでに支払われている人がいた場合、この操作は不可)」の操作のみ可。ただし、「approvedからfully_repaid」の操作はここでは行えない。accountManager権限または作成者権限が必要。
         * @param {string} applicationID 
         * @param {PutStatus} putStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putStatus(applicationID: string, putStatus: PutStatus, options?: any): AxiosPromise<StatusDetail> {
            return localVarFp.putStatus(applicationID, putStatus, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * 指定した申請の詳細を取得する。
     * @param {string} applicationID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplicationDetail(applicationID: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplicationDetail(applicationID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 申請一覧を取得する。
     * @param {string} [sort] 並び順 (作成日時が新しい \&quot;created_at\&quot;, 作成日時が古い \&quot;-created_at\&quot;, タイトルの昇順 \&quot;title\&quot;, タイトルの降順 \&quot;-title\&quot;)
     * @param {StatusEnum} [status] 現在の状態
     * @param {string} [target] 誰との取引か
     * @param {string} [since] いつからの依頼か
     * @param {string} [until] いつまでの依頼か
     * @param {number} [limit] 取得する最大個数
     * @param {number} [offset] スキップする個数
     * @param {string} [tag] タグ(複数の場合カンマ区切り)
     * @param {string} [partition] パーティション
     * @param {string} [createdBy] 作成者
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplications(sort?: string, status?: StatusEnum, target?: string, since?: string, until?: string, limit?: number, offset?: number, tag?: string, partition?: string, createdBy?: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplications(sort, status, target, since, until, limit, offset, tag, partition, createdBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 申請を新規作成する。
     * @param {PostApplication} postApplication 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public postApplication(postApplication: PostApplication, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).postApplication(postApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定した申請にコメントを新規作成する。
     * @param {string} applicationID 
     * @param {PostComment} postComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public postComment(applicationID: string, postComment: PostComment, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).postComment(applicationID, postComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定した申請を修正する。作成者権限が必要。
     * @param {string} applicationID 
     * @param {PostApplication} postApplication 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public putApplicationDetail(applicationID: string, postApplication: PostApplication, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).putApplicationDetail(applicationID, postApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定した申請のstatusを変更のみ(新規はpost /applications)する。commentは常に必須(ないときは空文字列)。statusの行き来の定義は作成者は「change_requestedからsubmitted」をでき、accountManagerは「submittedからrejected」「submittedからchange_requested」「change_requestedからsubmitted」「submittedからapproved」「approvedからsubmitted（ただしすでに支払われている人がいた場合、この操作は不可)」の操作のみ可。ただし、「approvedからfully_repaid」の操作はここでは行えない。accountManager権限または作成者権限が必要。
     * @param {string} applicationID 
     * @param {PutStatus} putStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public putStatus(applicationID: string, putStatus: PutStatus, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).putStatus(applicationID, putStatus, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * PKCEを取得する｡
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePKCE: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/genpkce`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * PKCEを取得する｡
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generatePKCE(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generatePKCE(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * PKCEを取得する｡
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePKCE(options?: any): AxiosPromise<void> {
            return localVarFp.generatePKCE(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * PKCEを取得する｡
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public generatePKCE(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).generatePKCE(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 指定したidのファイルを削除する。accountManager権限または作成者権限が必要。
         * @param {string} fileID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (fileID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('deleteFile', 'fileID', fileID)
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたファイルを返す
         * @param {string} fileID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (fileID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('getFile', 'fileID', fileID)
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 指定されたファイルのメタデータを返す
         * @param {string} fileID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta: async (fileID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('getFileMeta', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/meta`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ファイルをアップロードする。
         * @param {any} file 
         * @param {string} name 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFile: async (file: any, name: string, applicationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('postFile', 'file', file)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('postFile', 'name', name)
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('postFile', 'applicationId', applicationId)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (applicationId !== undefined) { 
                localVarFormParams.append('application_id', applicationId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 指定したidのファイルを削除する。accountManager権限または作成者権限が必要。
         * @param {string} fileID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(fileID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(fileID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定されたファイルを返す
         * @param {string} fileID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(fileID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(fileID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 指定されたファイルのメタデータを返す
         * @param {string} fileID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileMeta(fileID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileMeta(fileID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ファイルをアップロードする。
         * @param {any} file 
         * @param {string} name 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFile(file: any, name: string, applicationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFile(file, name, applicationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 指定したidのファイルを削除する。accountManager権限または作成者権限が必要。
         * @param {string} fileID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFile(fileID, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたファイルを返す
         * @param {string} fileID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileID: string, options?: any): AxiosPromise<any> {
            return localVarFp.getFile(fileID, options).then((request) => request(axios, basePath));
        },
        /**
         * 指定されたファイルのメタデータを返す
         * @param {string} fileID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileMeta(fileID: string, options?: any): AxiosPromise<FileMeta> {
            return localVarFp.getFileMeta(fileID, options).then((request) => request(axios, basePath));
        },
        /**
         * ファイルをアップロードする。
         * @param {any} file 
         * @param {string} name 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFile(file: any, name: string, applicationId: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.postFile(file, name, applicationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 指定したidのファイルを削除する。accountManager権限または作成者権限が必要。
     * @param {string} fileID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFile(fileID: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFile(fileID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたファイルを返す
     * @param {string} fileID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(fileID: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(fileID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたファイルのメタデータを返す
     * @param {string} fileID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileMeta(fileID: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileMeta(fileID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ファイルをアップロードする。
     * @param {any} file 
     * @param {string} name 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public postFile(file: any, name: string, applicationId: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).postFile(file, name, applicationId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PartitionsApi - axios parameter creator
 * @export
 */
export const PartitionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * パーティションを削除する。accountManager権限が必要。
         * @param {string} partitionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartition: async (partitionID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partitionID' is not null or undefined
            assertParamExists('deletePartition', 'partitionID', partitionID)
            const localVarPath = `/partitions/{partitionID}`
                .replace(`{${"partitionID"}}`, encodeURIComponent(String(partitionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パーティションの情報を返す。
         * @param {string} partitionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartition: async (partitionID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partitionID' is not null or undefined
            assertParamExists('getPartition', 'partitionID', partitionID)
            const localVarPath = `/partitions/{partitionID}`
                .replace(`{${"partitionID"}}`, encodeURIComponent(String(partitionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パーティションの一覧を返す。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パーティションを追加する。accountManager権限が必要。
         * @param {PostPartition} postPartition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPartition: async (postPartition: PostPartition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postPartition' is not null or undefined
            assertParamExists('postPartition', 'postPartition', postPartition)
            const localVarPath = `/partitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postPartition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * パーティションの情報を変更する。accountManager権限が必要。
         * @param {string} partitionID 
         * @param {PostPartition} postPartition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPartition: async (partitionID: string, postPartition: PostPartition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partitionID' is not null or undefined
            assertParamExists('putPartition', 'partitionID', partitionID)
            // verify required parameter 'postPartition' is not null or undefined
            assertParamExists('putPartition', 'postPartition', postPartition)
            const localVarPath = `/partitions/{partitionID}`
                .replace(`{${"partitionID"}}`, encodeURIComponent(String(partitionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postPartition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartitionsApi - functional programming interface
 * @export
 */
export const PartitionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartitionsApiAxiosParamCreator(configuration)
    return {
        /**
         * パーティションを削除する。accountManager権限が必要。
         * @param {string} partitionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePartition(partitionID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePartition(partitionID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * パーティションの情報を返す。
         * @param {string} partitionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartition(partitionID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartition(partitionID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * パーティションの一覧を返す。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartitions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Partition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartitions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * パーティションを追加する。accountManager権限が必要。
         * @param {PostPartition} postPartition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPartition(postPartition: PostPartition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPartition(postPartition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * パーティションの情報を変更する。accountManager権限が必要。
         * @param {string} partitionID 
         * @param {PostPartition} postPartition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putPartition(partitionID: string, postPartition: PostPartition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPartition(partitionID, postPartition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PartitionsApi - factory interface
 * @export
 */
export const PartitionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartitionsApiFp(configuration)
    return {
        /**
         * パーティションを削除する。accountManager権限が必要。
         * @param {string} partitionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartition(partitionID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePartition(partitionID, options).then((request) => request(axios, basePath));
        },
        /**
         * パーティションの情報を返す。
         * @param {string} partitionID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartition(partitionID: string, options?: any): AxiosPromise<Partition> {
            return localVarFp.getPartition(partitionID, options).then((request) => request(axios, basePath));
        },
        /**
         * パーティションの一覧を返す。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitions(options?: any): AxiosPromise<Array<Partition>> {
            return localVarFp.getPartitions(options).then((request) => request(axios, basePath));
        },
        /**
         * パーティションを追加する。accountManager権限が必要。
         * @param {PostPartition} postPartition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPartition(postPartition: PostPartition, options?: any): AxiosPromise<Partition> {
            return localVarFp.postPartition(postPartition, options).then((request) => request(axios, basePath));
        },
        /**
         * パーティションの情報を変更する。accountManager権限が必要。
         * @param {string} partitionID 
         * @param {PostPartition} postPartition 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPartition(partitionID: string, postPartition: PostPartition, options?: any): AxiosPromise<Partition> {
            return localVarFp.putPartition(partitionID, postPartition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartitionsApi - object-oriented interface
 * @export
 * @class PartitionsApi
 * @extends {BaseAPI}
 */
export class PartitionsApi extends BaseAPI {
    /**
     * パーティションを削除する。accountManager権限が必要。
     * @param {string} partitionID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartitionsApi
     */
    public deletePartition(partitionID: string, options?: AxiosRequestConfig) {
        return PartitionsApiFp(this.configuration).deletePartition(partitionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パーティションの情報を返す。
     * @param {string} partitionID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartitionsApi
     */
    public getPartition(partitionID: string, options?: AxiosRequestConfig) {
        return PartitionsApiFp(this.configuration).getPartition(partitionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パーティションの一覧を返す。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartitionsApi
     */
    public getPartitions(options?: AxiosRequestConfig) {
        return PartitionsApiFp(this.configuration).getPartitions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パーティションを追加する。accountManager権限が必要。
     * @param {PostPartition} postPartition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartitionsApi
     */
    public postPartition(postPartition: PostPartition, options?: AxiosRequestConfig) {
        return PartitionsApiFp(this.configuration).postPartition(postPartition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パーティションの情報を変更する。accountManager権限が必要。
     * @param {string} partitionID 
     * @param {PostPartition} postPartition 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartitionsApi
     */
    public putPartition(partitionID: string, postPartition: PostPartition, options?: AxiosRequestConfig) {
        return PartitionsApiFp(this.configuration).putPartition(partitionID, postPartition, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * タグの情報を取得する。
         * @param {string} tagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag: async (tagID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagID' is not null or undefined
            assertParamExists('getTag', 'tagID', tagID)
            const localVarPath = `/tags/{tagID}`
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * タグの一覧を返す。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * タグを追加する。
         * @param {PostTag} postTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTag: async (postTag: PostTag, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postTag' is not null or undefined
            assertParamExists('postTag', 'postTag', postTag)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * タグを削除する
         * @param {string} tagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsTagIDDelete: async (tagID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagID' is not null or undefined
            assertParamExists('tagsTagIDDelete', 'tagID', tagID)
            const localVarPath = `/tags/{tagID}`
                .replace(`{${"tagID"}}`, encodeURIComponent(String(tagID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * タグの情報を取得する。
         * @param {string} tagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTag(tagID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTag(tagID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * タグの一覧を返す。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * タグを追加する。
         * @param {PostTag} postTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTag(postTag: PostTag, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTag(postTag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * タグを削除する
         * @param {string} tagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsTagIDDelete(tagID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsTagIDDelete(tagID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * タグの情報を取得する。
         * @param {string} tagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTag(tagID: string, options?: any): AxiosPromise<Tag & object> {
            return localVarFp.getTag(tagID, options).then((request) => request(axios, basePath));
        },
        /**
         * タグの一覧を返す。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getTags(options).then((request) => request(axios, basePath));
        },
        /**
         * タグを追加する。
         * @param {PostTag} postTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTag(postTag: PostTag, options?: any): AxiosPromise<Tag> {
            return localVarFp.postTag(postTag, options).then((request) => request(axios, basePath));
        },
        /**
         * タグを削除する
         * @param {string} tagID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsTagIDDelete(tagID: string, options?: any): AxiosPromise<void> {
            return localVarFp.tagsTagIDDelete(tagID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * タグの情報を取得する。
     * @param {string} tagID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTag(tagID: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTag(tagID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * タグの一覧を返す。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * タグを追加する。
     * @param {PostTag} postTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public postTag(postTag: PostTag, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).postTag(postTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * タグを削除する
     * @param {string} tagID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsTagIDDelete(tagID: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsTagIDDelete(tagID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 自分の情報を取得する。存在しない場合はユーザーを作成する。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ユーザー一覧を取得する。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 自分の情報を取得する。存在しない場合はユーザーを作成する。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ユーザー一覧を取得する。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 自分の情報を取得する。存在しない場合はユーザーを作成する。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<User> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * ユーザー一覧を取得する。
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 自分の情報を取得する。存在しない場合はユーザーを作成する。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMe(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー一覧を取得する。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }
}

export class Apis extends BaseAPI {
    /**
     * accountManagerユーザーを削除する。accountManager権限が必要。
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountManagersApi
     */
    public deleteAccountManagers(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return AccountManagersApiFp(this.configuration).deleteAccountManagers(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * accountManagerユーザーの一覧を返す。accountManager権限が必要。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountManagersApi
     */
    public getAccountManagers(options?: AxiosRequestConfig) {
        return AccountManagersApiFp(this.configuration).getAccountManagers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * accountManagerユーザーを追加する。accountManager権限が必要。
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountManagersApi
     */
    public postAccountManagers(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return AccountManagersApiFp(this.configuration).postAccountManagers(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定した申請の詳細を取得する。
     * @param {string} applicationID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplicationDetail(applicationID: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplicationDetail(applicationID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 申請一覧を取得する。
     * @param {string} [sort] 並び順 (作成日時が新しい \&quot;created_at\&quot;, 作成日時が古い \&quot;-created_at\&quot;, タイトルの昇順 \&quot;title\&quot;, タイトルの降順 \&quot;-title\&quot;)
     * @param {StatusEnum} [status] 現在の状態
     * @param {string} [target] 誰との取引か
     * @param {string} [since] いつからの依頼か
     * @param {string} [until] いつまでの依頼か
     * @param {number} [limit] 取得する最大個数
     * @param {number} [offset] スキップする個数
     * @param {string} [tag] タグ(複数の場合カンマ区切り)
     * @param {string} [partition] パーティション
     * @param {string} [createdBy] 作成者
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplications(sort?: string, status?: StatusEnum, target?: string, since?: string, until?: string, limit?: number, offset?: number, tag?: string, partition?: string, createdBy?: string, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplications(sort, status, target, since, until, limit, offset, tag, partition, createdBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 申請を新規作成する。
     * @param {PostApplication} postApplication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public postApplication(postApplication: PostApplication, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).postApplication(postApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定した申請にコメントを新規作成する。
     * @param {string} applicationID
     * @param {PostComment} postComment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public postComment(applicationID: string, postComment: PostComment, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).postComment(applicationID, postComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定した申請を修正する。作成者権限が必要。
     * @param {string} applicationID
     * @param {PostApplication} postApplication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public putApplicationDetail(applicationID: string, postApplication: PostApplication, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).putApplicationDetail(applicationID, postApplication, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定した申請のstatusを変更のみ(新規はpost /applications)する。commentは常に必須(ないときは空文字列)。statusの行き来の定義は作成者は「change_requestedからsubmitted」をでき、accountManagerは「submittedからrejected」「submittedからchange_requested」「change_requestedからsubmitted」「submittedからapproved」「approvedからsubmitted（ただしすでに支払われている人がいた場合、この操作は不可)」の操作のみ可。ただし、「approvedからfully_repaid」の操作はここでは行えない。accountManager権限または作成者権限が必要。
     * @param {string} applicationID
     * @param {PutStatus} putStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public putStatus(applicationID: string, putStatus: PutStatus, options?: AxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).putStatus(applicationID, putStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PKCEを取得する｡
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public generatePKCE(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).generatePKCE(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定したidのファイルを削除する。accountManager権限または作成者権限が必要。
     * @param {string} fileID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFile(fileID: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFile(fileID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたファイルを返す
     * @param {string} fileID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(fileID: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(fileID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 指定されたファイルのメタデータを返す
     * @param {string} fileID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFileMeta(fileID: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFileMeta(fileID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ファイルをアップロードする。
     * @param {any} file
     * @param {string} name
     * @param {string} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public postFile(file: any, name: string, applicationId: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).postFile(file, name, applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パーティションを削除する。accountManager権限が必要。
     * @param {string} partitionID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartitionsApi
     */
    public deletePartition(partitionID: string, options?: AxiosRequestConfig) {
        return PartitionsApiFp(this.configuration).deletePartition(partitionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パーティションの情報を返す。
     * @param {string} partitionID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartitionsApi
     */
    public getPartition(partitionID: string, options?: AxiosRequestConfig) {
        return PartitionsApiFp(this.configuration).getPartition(partitionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パーティションの一覧を返す。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartitionsApi
     */
    public getPartitions(options?: AxiosRequestConfig) {
        return PartitionsApiFp(this.configuration).getPartitions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パーティションを追加する。accountManager権限が必要。
     * @param {PostPartition} postPartition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartitionsApi
     */
    public postPartition(postPartition: PostPartition, options?: AxiosRequestConfig) {
        return PartitionsApiFp(this.configuration).postPartition(postPartition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * パーティションの情報を変更する。accountManager権限が必要。
     * @param {string} partitionID
     * @param {PostPartition} postPartition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartitionsApi
     */
    public putPartition(partitionID: string, postPartition: PostPartition, options?: AxiosRequestConfig) {
        return PartitionsApiFp(this.configuration).putPartition(partitionID, postPartition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * タグの情報を取得する。
     * @param {string} tagID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTag(tagID: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTag(tagID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * タグの一覧を返す。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * タグを追加する。
     * @param {PostTag} postTag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public postTag(postTag: PostTag, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).postTag(postTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * タグを削除する
     * @param {string} tagID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsTagIDDelete(tagID: string, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsTagIDDelete(tagID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 自分の情報を取得する。存在しない場合はユーザーを作成する。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMe(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ユーザー一覧を取得する。
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }
}
